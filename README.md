# EditBook

晨会分享：多维度缓存的思考与实现
为什么要用缓存？
缓存网络请求数据，在弱网场景下呈现数据

为什么要用lru？
全部缓存占用磁盘空间巨大，要有选择性的存储，lru会优先保存用户最新使用的数据

为什么要用lfu？
不一定所有场景下最新使用的就是最需要保存的，有一些使用频次极高的更需要优先保存，比如首页

为什么要选以下两道题实现？
不同于常见的算法，lru、lfu考察的更多的是工程能力，如何优雅的实现？使用泛型或者是结构体还是接口，都是对于开发者基础能力的一个考察。
最为重要的是开发者的调试能力，初次完成 lfu 会遇见代码 5 分钟调试一整天的尴尬问题，是否能在短时间 debug 出复杂代码的 bug 都是对一个开发者是否合格的考核标准

实现 LRUCache 类
LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
https://leetcode-cn.com/problems/lru-cache

题目链接
实现 LFUCache 类
LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。
void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。
注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。
为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。
当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。
链接：https://leetcode-cn.com/problems/lfu-cache
